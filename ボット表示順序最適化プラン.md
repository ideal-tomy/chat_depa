# ボット表示順序最適化プラン

## 概要

ユーザーの利用頻度を最大化し、サイトの使いやすさを向上させるため、ボットの表示順序を動的に最適化するシステムを構築します。利用統計、管理者設定、ユーザー行動分析を組み合わせた多層的な表示ロジックを実装します。

## 1. データベース設計

### 1.1 新規テーブル追加

#### `bot_usage_stats` テーブル
```sql
CREATE TABLE bot_usage_stats (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  total_uses INTEGER DEFAULT 0,
  unique_users INTEGER DEFAULT 0,
  avg_session_duration INTEGER DEFAULT 0, -- 秒単位
  completion_rate DECIMAL(5,2) DEFAULT 0.0, -- 会話完了率
  user_rating DECIMAL(3,2) DEFAULT 0.0, -- 平均評価
  last_used_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### `bot_featured_settings` テーブル
```sql
CREATE TABLE bot_featured_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  display_type VARCHAR(50) NOT NULL, -- 'pickup', 'new', 'trending', 'category_featured'
  category_id VARCHAR(100), -- カテゴリ別設定用
  priority INTEGER DEFAULT 0, -- 表示優先度（高いほど上位）
  start_date DATE,
  end_date DATE,
  is_active BOOLEAN DEFAULT true,
  created_by UUID REFERENCES auth.users(id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### `bot_user_interactions` テーブル
```sql
CREATE TABLE bot_user_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  interaction_type VARCHAR(50) NOT NULL, -- 'view', 'start_chat', 'complete_chat', 'rate', 'favorite'
  session_duration INTEGER, -- 秒単位
  rating INTEGER, -- 1-5の評価
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 1.2 既存テーブル拡張

#### `bots` テーブルに追加
```sql
ALTER TABLE bots ADD COLUMN IF NOT EXISTS featured_priority INTEGER DEFAULT 0;
ALTER TABLE bots ADD COLUMN IF NOT EXISTS is_pickup BOOLEAN DEFAULT false;
ALTER TABLE bots ADD COLUMN IF NOT EXISTS is_new BOOLEAN DEFAULT false;
ALTER TABLE bots ADD COLUMN IF NOT EXISTS is_trending BOOLEAN DEFAULT false;
ALTER TABLE bots ADD COLUMN IF NOT EXISTS manual_sort_order INTEGER DEFAULT 0;
```

## 2. 表示ロジック設計

### 2.1 多層表示システム

#### レイヤー1: 管理者指定（最優先）
- ピックアップボット
- 新着ボット
- 注目ボット
- カテゴリ別特集ボット

#### レイヤー2: 動的ランキング
- 利用頻度ランキング
- ユーザー評価ランキング
- 完了率ランキング
- 新着度ランキング

#### レイヤー3: パーソナライゼーション
- ユーザーの過去利用履歴
- 類似ボット推薦
- カテゴリ別好み分析

### 2.2 表示順序計算アルゴリズム

```typescript
interface BotDisplayScore {
  botId: string;
  score: number;
  factors: {
    manualPriority: number;    // 管理者設定優先度
    usageScore: number;        // 利用頻度スコア
    ratingScore: number;       // 評価スコア
    recencyScore: number;      // 新着度スコア
    personalizationScore: number; // パーソナライゼーションスコア
  };
}

function calculateDisplayScore(bot: Bot, userContext?: UserContext): BotDisplayScore {
  const score = {
    manualPriority: bot.featured_priority * 1000,
    usageScore: calculateUsageScore(bot.usage_stats),
    ratingScore: calculateRatingScore(bot.usage_stats),
    recencyScore: calculateRecencyScore(bot.created_at),
    personalizationScore: calculatePersonalizationScore(bot, userContext)
  };

  return {
    botId: bot.id,
    score: Object.values(score).reduce((sum, val) => sum + val, 0),
    factors: score
  };
}
```

## 3. 実装計画

### 3.1 Phase 1: 基本統計システム（1-2週間）

#### 3.1.1 利用統計収集API
```typescript
// src/app/api/bot/stats/update/route.ts
export async function POST(req: NextRequest) {
  const { botId, userId, interactionType, sessionData } = await req.json();
  
  // 利用統計を更新
  await updateBotUsageStats(botId, userId, interactionType, sessionData);
  
  // リアルタイムランキングを更新
  await updateBotRankings();
}
```

#### 3.1.2 統計計算バッチ処理
```typescript
// src/lib/bot-stats/calculate-rankings.ts
export async function calculateBotRankings() {
  // 日次ランキング計算
  // 週次ランキング計算
  // 月次ランキング計算
}
```

### 3.2 Phase 2: 管理者設定システム（1週間）

#### 3.2.1 管理者ダッシュボード拡張
- ピックアップボット設定
- 新着ボット設定
- カテゴリ別特集設定
- 手動優先度設定

#### 3.2.2 設定API
```typescript
// src/app/api/admin/bot-featured/route.ts
export async function POST(req: NextRequest) {
  const { botId, displayType, priority, categoryId, startDate, endDate } = await req.json();
  
  await setBotFeatured(botId, {
    displayType,
    priority,
    categoryId,
    startDate,
    endDate
  });
}
```

### 3.3 Phase 3: パーソナライゼーション（2週間）

#### 3.3.1 ユーザー行動分析
```typescript
// src/lib/user-analytics/analyze-preferences.ts
export async function analyzeUserPreferences(userId: string) {
  // 利用履歴分析
  // カテゴリ別好み分析
  // 類似ボット推薦
}
```

#### 3.3.2 推薦システム
```typescript
// src/lib/recommendation/engine.ts
export async function getPersonalizedRecommendations(userId: string) {
  const userPreferences = await analyzeUserPreferences(userId);
  const recommendations = await generateRecommendations(userPreferences);
  return recommendations;
}
```

## 4. フロントエンド実装

### 4.1 表示コンポーネント拡張

#### 4.1.1 動的カルーセルコンポーネント
```typescript
// src/components/ui/DynamicCarousel.tsx
interface DynamicCarouselProps {
  displayType: 'pickup' | 'new' | 'trending' | 'category_featured';
  categoryId?: string;
  maxItems?: number;
  showRanking?: boolean;
}

export default function DynamicCarousel({ 
  displayType, 
  categoryId, 
  maxItems = 10,
  showRanking = false 
}: DynamicCarouselProps) {
  const [bots, setBots] = useState<Bot[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchDynamicBots(displayType, categoryId, maxItems);
  }, [displayType, categoryId, maxItems]);

  return (
    <div className="dynamic-carousel">
      {showRanking && (
        <div className="ranking-badges">
          {bots.map((bot, index) => (
            <RankingBadge key={bot.id} rank={index + 1} />
          ))}
        </div>
      )}
      <Carousel items={bots} />
    </div>
  );
}
```

#### 4.1.2 管理者設定UI
```typescript
// src/components/admin/BotFeaturedSettings.tsx
export default function BotFeaturedSettings() {
  return (
    <div className="bot-featured-settings">
      <Tabs>
        <Tab label="ピックアップ設定">
          <PickupBotSelector />
        </Tab>
        <Tab label="新着設定">
          <NewBotSelector />
        </Tab>
        <Tab label="カテゴリ特集">
          <CategoryFeaturedSelector />
        </Tab>
        <Tab label="手動優先度">
          <ManualPrioritySetter />
        </Tab>
      </Tabs>
    </div>
  );
}
```

### 4.2 ページ別表示ロジック

#### 4.2.1 トップページ
```typescript
// src/app/page.tsx
export default function HomePage() {
  return (
    <main>
      {/* 管理者指定ピックアップ */}
      <DynamicCarousel displayType="pickup" maxItems={6} showRanking={true} />
      
      {/* 新着ボット */}
      <DynamicCarousel displayType="new" maxItems={8} />
      
      {/* カテゴリ別特集 */}
      {categories.map(category => (
        <DynamicCarousel 
          key={category.id}
          displayType="category_featured" 
          categoryId={category.id}
          maxItems={6}
        />
      ))}
      
      {/* トレンドボット */}
      <DynamicCarousel displayType="trending" maxItems={10} showRanking={true} />
    </main>
  );
}
```

#### 4.2.2 ボット一覧ページ
```typescript
// src/components/bots/BotPageClient.tsx
export default function BotPageClient() {
  const [sortMethod, setSortMethod] = useState<'popular' | 'newest' | 'rating' | 'trending'>('popular');
  
  const fetchBots = useCallback(async (filters: FilterState, isLoadMore = false) => {
    const response = await fetch(`/api/bots?sort=${sortMethod}&category=${filters.category}&page=${page}`);
    // 動的ランキングに基づくボット取得
  }, [sortMethod, filters, page]);
}
```

## 5. API設計

### 5.1 動的ボット取得API
```typescript
// src/app/api/bots/dynamic/route.ts
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const displayType = searchParams.get('type');
  const categoryId = searchParams.get('category');
  const maxItems = parseInt(searchParams.get('limit') || '10');
  const userId = await getCurrentUserId();

  const bots = await getDynamicBots({
    displayType,
    categoryId,
    maxItems,
    userId
  });

  return NextResponse.json({ bots });
}
```

### 5.2 統計更新API
```typescript
// src/app/api/bot/interaction/route.ts
export async function POST(req: NextRequest) {
  const { botId, interactionType, sessionData } = await req.json();
  const userId = await getCurrentUserId();

  await recordBotInteraction({
    botId,
    userId,
    interactionType,
    sessionData
  });

  return NextResponse.json({ success: true });
}
```

## 6. 運用・監視

### 6.1 パフォーマンス監視
- ボット表示順序の効果測定
- ユーザーエンゲージメント分析
- クリック率・利用率の追跡

### 6.2 A/Bテスト機能
```typescript
// src/lib/ab-testing/display-variants.ts
export const DISPLAY_VARIANTS = {
  CONTROL: 'manual_only',
  VARIANT_A: 'dynamic_ranking',
  VARIANT_B: 'personalized',
  VARIANT_C: 'hybrid'
};
```

### 6.3 自動最適化
- 利用統計に基づく自動ランキング調整
- 季節性・トレンドを考慮した表示調整
- ユーザーフィードバックによる継続改善

## 7. 実装スケジュール

### Week 1-2: 基盤構築
- データベーステーブル作成
- 基本統計収集システム
- 利用統計API実装

### Week 3: 管理者機能
- 管理者ダッシュボード拡張
- ピックアップ・新着設定機能
- 手動優先度設定

### Week 4-5: 動的ランキング
- ランキング計算アルゴリズム
- リアルタイム統計更新
- 表示順序最適化

### Week 6-7: パーソナライゼーション
- ユーザー行動分析
- 推薦システム
- 個人化表示

### Week 8: テスト・最適化
- A/Bテスト実装
- パフォーマンス最適化
- ユーザビリティテスト

## 8. 期待効果

### 8.1 ユーザー体験向上
- 関連性の高いボットが上位表示
- 新着・注目ボットの発見促進
- カテゴリ別最適化

### 8.2 ビジネス効果
- ボット利用率向上
- ユーザー滞在時間延長
- リピート率向上

### 8.3 運用効率化
- データ駆動の表示最適化
- 管理者の手動調整負荷軽減
- 継続的な改善サイクル

## 9. 技術的考慮事項

### 9.1 パフォーマンス
- ランキング計算のキャッシュ
- リアルタイム更新の最適化
- データベースクエリの効率化

### 9.2 スケーラビリティ
- 統計データの定期的な集約
- 古いデータのアーカイブ
- 負荷分散の実装

### 9.3 プライバシー
- ユーザーデータの匿名化
- 個人情報の適切な管理
- GDPR準拠の実装

## 10. 関連ボット推薦システム

### 10.1 推薦アルゴリズム設計

#### 10.1.1 協調フィルタリング（Collaborative Filtering）
```typescript
interface UserBotInteraction {
  userId: string;
  botId: string;
  interactionStrength: number; // 利用頻度、評価、セッション時間から計算
  timestamp: Date;
}

interface BotSimilarity {
  botId1: string;
  botId2: string;
  similarityScore: number; // 0-1の類似度スコア
  commonUsers: number; // 共通利用ユーザー数
}

// ユーザー間の類似度計算
function calculateUserSimilarity(user1: string, user2: string): number {
  const user1Bots = getUserBotInteractions(user1);
  const user2Bots = getUserBotInteractions(user2);
  
  const intersection = user1Bots.filter(bot => 
    user2Bots.some(u2Bot => u2Bot.botId === bot.botId)
  );
  
  const union = [...user1Bots, ...user2Bots];
  return intersection.length / union.length; // Jaccard類似度
}

// ボット間の類似度計算
function calculateBotSimilarity(bot1: string, bot2: string): number {
  const bot1Users = getBotUsers(bot1);
  const bot2Users = getBotUsers(bot2);
  
  const commonUsers = bot1Users.filter(user => 
    bot2Users.includes(user)
  );
  
  return commonUsers.length / Math.sqrt(bot1Users.length * bot2Users.length);
}
```

#### 10.1.2 コンテンツベースフィルタリング
```typescript
interface BotFeatures {
  botId: string;
  category: string;
  tags: string[];
  complexity: 'simple' | 'medium' | 'advanced';
  useCases: string[];
  targetAudience: string[];
  features: string[]; // 画像アップロード、ファイル送信など
}

function calculateContentSimilarity(bot1: BotFeatures, bot2: BotFeatures): number {
  const categoryMatch = bot1.category === bot2.category ? 0.3 : 0;
  const tagOverlap = calculateTagOverlap(bot1.tags, bot2.tags) * 0.2;
  const complexityMatch = bot1.complexity === bot2.complexity ? 0.1 : 0;
  const useCaseOverlap = calculateUseCaseOverlap(bot1.useCases, bot2.useCases) * 0.2;
  const audienceMatch = calculateAudienceOverlap(bot1.targetAudience, bot2.targetAudience) * 0.1;
  const featureMatch = calculateFeatureOverlap(bot1.features, bot2.features) * 0.1;
  
  return categoryMatch + tagOverlap + complexityMatch + useCaseOverlap + audienceMatch + featureMatch;
}
```

### 10.2 データベース設計（追加）

#### `bot_recommendations` テーブル
```sql
CREATE TABLE bot_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  source_bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  recommended_bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  recommendation_type VARCHAR(50) NOT NULL, -- 'collaborative', 'content_based', 'hybrid'
  similarity_score DECIMAL(5,4) NOT NULL,
  confidence_score DECIMAL(5,4) NOT NULL,
  click_through_rate DECIMAL(5,4) DEFAULT 0.0,
  conversion_rate DECIMAL(5,4) DEFAULT 0.0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(source_bot_id, recommended_bot_id)
);

-- インデックス
CREATE INDEX idx_bot_recommendations_source ON bot_recommendations(source_bot_id);
CREATE INDEX idx_bot_recommendations_score ON bot_recommendations(similarity_score DESC);
```

#### `user_recommendation_feedback` テーブル
```sql
CREATE TABLE user_recommendation_feedback (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id),
  source_bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  recommended_bot_id UUID REFERENCES bots(id) ON DELETE CASCADE,
  action_type VARCHAR(50) NOT NULL, -- 'view', 'click', 'use', 'dismiss'
  session_id UUID,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### 10.3 推薦システムAPI

#### 10.3.1 関連ボット取得API
```typescript
// src/app/api/bot/recommendations/route.ts
export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const botId = searchParams.get('botId');
  const userId = searchParams.get('userId');
  const limit = parseInt(searchParams.get('limit') || '6');
  const type = searchParams.get('type') || 'hybrid'; // 'collaborative', 'content_based', 'hybrid'

  if (!botId) {
    return NextResponse.json({ error: 'botId is required' }, { status: 400 });
  }

  const recommendations = await getBotRecommendations({
    botId,
    userId,
    limit,
    type
  });

  return NextResponse.json({ recommendations });
}

async function getBotRecommendations({
  botId,
  userId,
  limit,
  type
}: {
  botId: string;
  userId?: string;
  limit: number;
  type: string;
}) {
  let recommendations = [];

  if (type === 'collaborative' || type === 'hybrid') {
    const collaborativeRecs = await getCollaborativeRecommendations(botId, limit);
    recommendations.push(...collaborativeRecs);
  }

  if (type === 'content_based' || type === 'hybrid') {
    const contentRecs = await getContentBasedRecommendations(botId, limit);
    recommendations.push(...contentRecs);
  }

  // 重複除去とスコア統合
  recommendations = mergeAndDeduplicateRecommendations(recommendations);
  
  // ユーザー固有の調整
  if (userId) {
    recommendations = await personalizeRecommendations(recommendations, userId);
  }

  return recommendations.slice(0, limit);
}
```

#### 10.3.2 推薦フィードバックAPI
```typescript
// src/app/api/bot/recommendation-feedback/route.ts
export async function POST(req: NextRequest) {
  const { sourceBotId, recommendedBotId, actionType, sessionId } = await req.json();
  const userId = await getCurrentUserId();

  await recordRecommendationFeedback({
    userId,
    sourceBotId,
    recommendedBotId,
    actionType,
    sessionId
  });

  // 推薦スコアの更新
  await updateRecommendationScores(sourceBotId, recommendedBotId, actionType);

  return NextResponse.json({ success: true });
}
```

### 10.4 フロントエンド実装

#### 10.4.1 関連ボット表示コンポーネント
```typescript
// src/components/bots/RelatedBotsRecommendation.tsx
interface RelatedBotsRecommendationProps {
  currentBotId: string;
  maxItems?: number;
  displayType?: 'sidebar' | 'carousel' | 'grid';
  showReason?: boolean;
}

export default function RelatedBotsRecommendation({
  currentBotId,
  maxItems = 6,
  displayType = 'carousel',
  showReason = true
}: RelatedBotsRecommendationProps) {
  const [recommendations, setRecommendations] = useState<BotRecommendation[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchRecommendations();
  }, [currentBotId]);

  const fetchRecommendations = async () => {
    try {
      const response = await fetch(`/api/bot/recommendations?botId=${currentBotId}&limit=${maxItems}`);
      const data = await response.json();
      setRecommendations(data.recommendations);
    } catch (error) {
      console.error('Failed to fetch recommendations:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleBotClick = async (recommendedBotId: string) => {
    // 推薦フィードバックを記録
    await fetch('/api/bot/recommendation-feedback', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sourceBotId: currentBotId,
        recommendedBotId,
        actionType: 'click',
        sessionId: generateSessionId()
      })
    });
  };

  if (loading) {
    return <RelatedBotsSkeleton count={maxItems} />;
  }

  return (
    <div className="related-bots-recommendation">
      <div className="recommendation-header">
        <h3 className="text-lg font-semibold mb-2">
          <span className="text-primary">💡</span> このボットを使った人は、こんなボットも使っています
        </h3>
        {showReason && (
          <p className="text-sm text-gray-600 mb-4">
            あなたの利用パターンと他のユーザーの行動から、関連性の高いボットをおすすめしています
          </p>
        )}
      </div>

      {displayType === 'carousel' && (
        <div className="recommendation-carousel">
          <Carousel items={recommendations} onItemClick={handleBotClick} />
        </div>
      )}

      {displayType === 'grid' && (
        <div className="recommendation-grid grid grid-cols-2 md:grid-cols-3 gap-4">
          {recommendations.map((rec) => (
            <BotRecommendationCard
              key={rec.bot.id}
              bot={rec.bot}
              reason={rec.reason}
              similarityScore={rec.similarityScore}
              onClick={() => handleBotClick(rec.bot.id)}
            />
          ))}
        </div>
      )}

      {displayType === 'sidebar' && (
        <div className="recommendation-sidebar space-y-3">
          {recommendations.map((rec) => (
            <BotRecommendationSidebarItem
              key={rec.bot.id}
              bot={rec.bot}
              reason={rec.reason}
              onClick={() => handleBotClick(rec.bot.id)}
            />
          ))}
        </div>
      )}
    </div>
  );
}
```

#### 10.4.2 推薦理由表示コンポーネント
```typescript
// src/components/bots/BotRecommendationCard.tsx
interface BotRecommendationCardProps {
  bot: Bot;
  reason: string;
  similarityScore: number;
  onClick: () => void;
}

export default function BotRecommendationCard({
  bot,
  reason,
  similarityScore,
  onClick
}: BotRecommendationCardProps) {
  return (
    <div 
      className="bot-recommendation-card bg-white rounded-lg shadow-sm border border-gray-100 hover:shadow-md transition-shadow cursor-pointer"
      onClick={onClick}
    >
      <div className="p-4">
        <div className="flex items-start space-x-3">
          <div className="flex-shrink-0">
            <BotAvatar bot={bot} size="sm" />
          </div>
          <div className="flex-1 min-w-0">
            <h4 className="text-sm font-medium text-gray-900 truncate">
              {bot.name}
            </h4>
            <p className="text-xs text-gray-500 mt-1 line-clamp-2">
              {bot.description}
            </p>
            <div className="flex items-center justify-between mt-2">
              <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                {reason}
              </span>
              <span className="text-xs text-gray-400">
                {Math.round(similarityScore * 100)}% マッチ
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 10.5 表示場所と実装戦略

#### 10.5.1 ボット詳細ページ
```typescript
// src/app/bots/[id]/page.tsx
export default function BotDetailPage({ params }: { params: { id: string } }) {
  return (
    <div className="bot-detail-page">
      <div className="main-content">
        <BotInfo botId={params.id} />
        <ChatInterface botId={params.id} />
      </div>
      
      <div className="sidebar">
        <RelatedBotsRecommendation
          currentBotId={params.id}
          displayType="sidebar"
          maxItems={4}
          showReason={true}
        />
      </div>
    </div>
  );
}
```

#### 10.5.2 チャット完了後の推薦
```typescript
// src/components/bots/ChatCompletionRecommendation.tsx
export default function ChatCompletionRecommendation({ 
  currentBotId, 
  chatHistory 
}: { 
  currentBotId: string; 
  chatHistory: ChatMessage[] 
}) {
  const [showRecommendations, setShowRecommendations] = useState(false);

  useEffect(() => {
    // チャットが完了したら推薦を表示
    if (chatHistory.length > 2) {
      setShowRecommendations(true);
    }
  }, [chatHistory]);

  if (!showRecommendations) return null;

  return (
    <div className="chat-completion-recommendation bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-6 mt-6">
      <div className="text-center mb-4">
        <h3 className="text-lg font-semibold text-gray-900">
          🎉 チャット完了！
        </h3>
        <p className="text-sm text-gray-600">
          関連するボットも試してみませんか？
        </p>
      </div>
      
      <RelatedBotsRecommendation
        currentBotId={currentBotId}
        displayType="carousel"
        maxItems={3}
        showReason={false}
      />
    </div>
  );
}
```

#### 10.5.3 ホームページのパーソナライズ推薦
```typescript
// src/components/home/PersonalizedRecommendations.tsx
export default function PersonalizedRecommendations() {
  const [userRecommendations, setUserRecommendations] = useState<Bot[]>([]);
  const { user } = useAuth();

  useEffect(() => {
    if (user) {
      fetchUserRecommendations();
    }
  }, [user]);

  const fetchUserRecommendations = async () => {
    const response = await fetch('/api/bot/recommendations/personalized');
    const data = await response.json();
    setUserRecommendations(data.recommendations);
  };

  if (!user || userRecommendations.length === 0) return null;

  return (
    <section className="personalized-recommendations mb-8">
      <div className="section-header">
        <h2 className="text-2xl font-bold mb-2">
          <span className="text-primary">✨</span> あなたにおすすめ
        </h2>
        <p className="text-gray-600">
          あなたの利用履歴から、関連性の高いボットをおすすめしています
        </p>
      </div>
      
      <div className="recommendations-grid grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {userRecommendations.map((bot) => (
          <BotCard key={bot.id} bot={bot} />
        ))}
      </div>
    </section>
  );
}
```

### 10.6 推薦アルゴリズムの最適化

#### 10.6.1 ハイブリッド推薦システム
```typescript
// src/lib/recommendation/hybrid-engine.ts
export class HybridRecommendationEngine {
  private collaborativeWeight = 0.6;
  private contentWeight = 0.4;

  async getHybridRecommendations(botId: string, userId?: string): Promise<BotRecommendation[]> {
    const [collaborativeRecs, contentRecs] = await Promise.all([
      this.getCollaborativeRecommendations(botId),
      this.getContentBasedRecommendations(botId)
    ]);

    const hybridRecs = this.mergeRecommendations(collaborativeRecs, contentRecs);
    
    if (userId) {
      return this.personalizeRecommendations(hybridRecs, userId);
    }

    return hybridRecs;
  }

  private mergeRecommendations(
    collaborative: BotRecommendation[],
    content: BotRecommendation[]
  ): BotRecommendation[] {
    const merged = new Map<string, BotRecommendation>();

    // 協調フィルタリング結果を追加
    collaborative.forEach(rec => {
      merged.set(rec.bot.id, {
        ...rec,
        similarityScore: rec.similarityScore * this.collaborativeWeight
      });
    });

    // コンテンツベース結果を統合
    content.forEach(rec => {
      const existing = merged.get(rec.bot.id);
      if (existing) {
        existing.similarityScore += rec.similarityScore * this.contentWeight;
        existing.reason = `${existing.reason} + ${rec.reason}`;
      } else {
        merged.set(rec.bot.id, {
          ...rec,
          similarityScore: rec.similarityScore * this.contentWeight
        });
      }
    });

    return Array.from(merged.values())
      .sort((a, b) => b.similarityScore - a.similarityScore);
  }
}
```

### 10.7 効果測定と改善

#### 10.7.1 推薦効果の測定
```typescript
// src/lib/analytics/recommendation-metrics.ts
export async function calculateRecommendationMetrics() {
  const metrics = {
    clickThroughRate: await calculateCTR(),
    conversionRate: await calculateConversionRate(),
    userSatisfaction: await calculateUserSatisfaction(),
    revenueImpact: await calculateRevenueImpact()
  };

  return metrics;
}

async function calculateCTR(): Promise<number> {
  const { data } = await supabase
    .from('user_recommendation_feedback')
    .select('action_type')
    .eq('action_type', 'click');

  const totalImpressions = await getTotalImpressions();
  return data.length / totalImpressions;
}
```

#### 10.7.2 A/Bテスト設定
```typescript
// src/lib/ab-testing/recommendation-variants.ts
export const RECOMMENDATION_VARIANTS = {
  CONTROL: {
    algorithm: 'collaborative_only',
    displayType: 'sidebar',
    maxItems: 4
  },
  VARIANT_A: {
    algorithm: 'hybrid',
    displayType: 'carousel',
    maxItems: 6
  },
  VARIANT_B: {
    algorithm: 'content_based',
    displayType: 'grid',
    maxItems: 8
  }
};
```

この推薦システムにより、ユーザーは関連性の高いボットを発見しやすくなり、サイトの利用頻度とユーザー満足度が大幅に向上します。特に「このボットを使った人は、こんなボットも使っています」という表示により、社会的証明効果も期待できます。
